/*!
\page interpreter_overview %Interpreter documentation.

The interpreter works like many standard interpreters by having a number of phases,
where each phase runs through the Abstract Syntax Tree, modifies it, and computes
some values that are used in the next traversal.
In this interpreter, we first parse the code, then we typecheck the code and
finally we generate the llvm byte code.

Tokenizing
==========
We use an autogenerated tokenizer to read the code and return tokens.
The program used for generating the tokenizer can be found here:
https://github.com/jasn/lexer_generator
That project has no dependencies and once compiled there is a help message
describing how to use the tool.
The lexer_generator tool takes as input a list of names and regular expressions.
The names are the token names and the regular expression is a description of how
to match that token. That input list is located in src/frontend/RASMUS.lang.
The generated files are src/frontend/tokenizer.hh and src/frontend/tokenizer.cc
-- DO NOT EDIT THEM, as they will be overwritten.

Note whenever the RASMUS language changes, (e.g. keywords are added) the
RASMUS.lang file is updated, and the src/frontend/tokenizer.hh and
src/frontend/tokenizer.cc files need to be updated. There is also need for
parsing in the GUI, so the files src/gui/table.hh and src/gui/table.cc also need
to be updated.

Lexing
======
The tokenizer is very primitive and holds almost no additional information after
returning a token. To provide various messages we need to augment the
information coming out of the tokenizer. This is done via
rasmus::frontend::Lexer. The next token is read via the lexer, which then
creates a rasmus::frontend::Token object, containing information such as
where that token is in the code. There also some helper methods that classify
tokens into operators and keywords.


Abstract Syntax Tree
====================
The AST nodes are autogenerated by the build system. The relevant file for
the AST nodes is the src/frontend/AST.txt file. This file is at compile time
parsed by tools/ASTGen.py and then 3 files are generated:
 - AST.hh
  - Contains all the derived Node types and implementations. I.e. what data
    is stored with each node. The base class is rasmus::frontend::Node.  
 - nodeType.hh
  - Contains an enum for the types of nodes.
 - visitor.hh
  - The base CRTP class to derive AST traversers from.

The syntax of AST.txt is as follows:
\<ClassName\>|\<list of member variables 1\>|\<list of member variables 2\>

- \<ClassName\>: The name of a derived rasmus::frontend::Node class.
I.e. it corresponds to some kind of expression, e.g. AssignmentExp.

- \<list of member variables 1\>: a comma seperated list of names. The names that
end with "Token" get the type rasmus::frontend::Token while the others get type
rasmus::frontend::NodePtr. These names are of course related to the expression
type, it typically contains the Token that is associated as well as child
expressions. E.g. an AssignmentExp will have a ':=' token, and it will have a
'nameToken' (the left hand side) and it will have a right hand side, which is
a normal expression, e.g. valueExp could be that name.
The names in this list will be arguments to the constructor.

- \<list of member variables 2\>: a vertical bar ('|') seperated list of type and
names. These become member variables, but not arguments to the constructor.
If '= xxx' is present the variable is constructed to have the xxx default value.
If no type is given, it becomes as rasmus::frontend::NodePtr, unless the name
ends with 'Token' in which case it becomes a rasmus::frontend::Token.
The type is verbatim inserted in the generated file.

The rasmus::frontend::VisitorCRTP class is a typical implementation of the
'Visitor' pattern but with static method dispatching rather than through virutal
dispatch via inheritance. This kind of implementation is typically faster as it
is branch predictable.

To implement a traverser of the AST (let us call it 'traverser_class'),
one needs to inherit from VisitorCRTP<traverser_class, return type of visiting>.
Then one needs to implement all the RT visit(std::shared_pointer<name>)
functions where 'name' is the name from the \<ClassName\> part of AST.txt.
When recursing to other expressions one calls visitNode(NodePtr node).
See e.g. rasmus::frontend::FirstParseImpl for example code on traversing.
There is no default behavior for non implemented visit functions, and it will
result in errors if no implementation is provided.

Parsing and Error Handling
==========================
The parser is implemented in the rasmus::frontend::TheParser class and its
interface is defined in rasmus::frontend::Parser.
The parser is a standard recursive descent parser with no backtracking. This is
possible since the RASMUS language is in LL(k) (for some k).
Recursive descent is also particularly nice, since it allows us to provide
useful error messages, as to what was expected and what actually occured.

Recovery
--------
When errors occur in a parse, we try to keep parsing and tell as many errors
as possible in one go.
Our method of 'keep parsing' is to keep a stack of open brackets (or similar
opening tokens), and when an error occurs, we find a matching end, and keep
parsing from there.


Type Checking
=============================

*/